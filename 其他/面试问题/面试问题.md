# 面试问题

## 常见 HTTP 状态码
1xx	处理信息，服务器收到请求，需要请求者继续执行操作
2xx	请求成功
3xx	重定向
4xx	客户端错误
5xx	服务器错误

## TCP/IP 五层模型和 OSI 七层模型
- 五层模型：物理层，链路层，网络层，传输层，应用层
- 七层模型：物理层，链路层，网络层，传输层，会话层，表示层，应用层

## 判断端到端之间是否存在防火墙
traceroute 用不同协议和端口去做排除

## GET 和 POST 请求有哪些区别
- GET 请求会被浏览器主动缓存，而 POST 不会
- GET 传递参数有大小限制，而 POST 没有
- POST 参数传输更安全，GET 的参数会明文限制在 URL 上，POST 不会

## 限流常用方法
计数器（固定窗口）算法，滑动窗口算法，漏桶算法、令牌桶算法

## TCP 粘包
TCP 粘包会导致解析网络包失败，可能发生在发送端或者接收端

- 发送端粘包：发送端需要等缓冲区满才发送出去，造成多个包粘一起
- 接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收

UDP 不会有粘包是因为 UDP 有消息保护边界。

## HTTP 响应码 301 和 302
301 表示永久重定向，302 表示暂时重定向

## session 和 cookie
存储位置不同，session 存储在服务器端，cookie 存储在浏览器端
安全性不同，cookie 安全性一般，在浏览器存储，可以被伪造和修改
容量和个数限制，cookie 有容量限制，每个站点下的 cookie 也有个数限制
存储的多样性，session可以存储在 Redis 中、数据库中、应用程序中，而 cookie 只能存储在浏览器中

## session 的工作原理
session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，
客户端再存储到浏览器中，这样客户端每次访问服务器时，都会带着 session id，服务器拿到 session id 之后，在内存找到与之对应的 session 这样就可以正常工作了。

客户端禁止 cookie 不会影响 session 的使用，session 只是依赖 cookie 存储 session id，如果 cookie 被禁用了，可以使用 URL 中添加 session id 的方式保证 session 能正常使用。

## CSRF 攻击
CSRF，Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，
比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。防御手段：验证请求来源地址、关键操作添加验证码、在请求地址添加token 并验证。

## XSS 攻击
XSS 攻击，即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（CSS 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等，预防XSS的核心是必须对输入的数据做过滤处理。

## forward 和 redirect 的区别
forward 是转发，redirect 是重定向；地址栏 URL 显示：forward URL 不会发生改变，redirect URL 会发生改变；数据共享：
forward 可以共享 request 里的数据，redirect不能共享；效率：forward 比 redirect 效率高。

## TCP 三次握手和四次挥手以及TIME_WAIT
[面试必备HTTP之TCP三次握手及四次挥手详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/12790cea57ac)

[简单理解TCP三次握手四次挥手（看一遍你就懂）-CSDN博客](https://blog.csdn.net/m0_56649557/article/details/119492899)

[终于搞懂了服务器为啥产生大量的TIME_WAIT！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/415307243)

三次握手，(SYN, SEQ=x) -> (SYN, ACK=x+1, SEQ=y) -> (ACK=y+1)，二次不行是因为 TCP 是面向连接的全双工，四次不行是没有必要消耗多余的一次网络传输。

四次挥手，(FIN, SEQ=x) -> (ACK=x+1) -> [服务端 CLOSE_WAIT 并发送完剩余数据] -> (FIN, SEQ=y) -> (ACK=y+1) -> [客户端 TIME_WAIT] -> (经过2MSL，默认四分钟后 CLOSED) ，四次挥手服务端 FIN 和 ACK 没有在一次传输发送是等待服务端把数据发送完，防止数据丢失。客户端等待 2MSL 是为了最后一个 ACK 能到达服务端帮助其关闭连接（假设服务端没有收到最后来自客户端的 ACK，那么会重新发送 FIN）；另外也是为了防止新连接中存在旧连接的报文（因为在 2MSL 时间内上次的网络包肯定已经不存在了）。

出现大量TIME_WAIT一般是由于短时间内大量请求，一般发生在客户端，由于 HTTP1.1(Header, Connection=close 时) 是服务端先断开连接，所以对于 HTTP 服务器来说服务端也会出现大量 TIME_WAIT。(Header, Connection 另一个选项是 keep-alive)


## MySQL 事务隔离级别
读未提交/读已提交/重复读/序列化

## 进程和线程的区别

## 同步和异步的区别

## 阻塞和非阻塞的区别

## Linux 创建进程系统调用 fork
