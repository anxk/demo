# 并查集

并查集常用来解决分组问题，也可以用于检测环。

## 路径压缩+按秩合并

```go
package main

func demo(members []int, relationship [][]int) { // 注意这里 relationship 中应该是 members 的下标
	fa, rank := make([]int, len(members)), make([]int, len(members))
	groupCnt := len(members) // groupCnt 初始值等于全体的数量
	for i := range fa {
		fa[i] = i
		rank[i] = 1 // rank 可以认为是树的高度
	}
	for _, rel := range relationship {
		if !connected(fa, rel[0], rel[1]) {
			merge(fa, rank, rel[0], rel[1])
			groupCnt--
		}
	}
}

func find(fa []int, x int) int {
	if fa[x] == x {
		return x
	}
	fa[x] = find(fa, fa[x])
	return fa[x]
}

func connected(fa []int, x, y int) bool {
	return find(fa, x) == find(fa, y)
}

func merge(fa, rank []int, x, y int) {
	fx, fy := find(fa, x), find(fa, y)
	if fx == fy {
		return
	}
	if rank[fx] >= rank[fy] {
		fa[fy] = fx
	} else {
		fa[fx] = fy
	}
	if rank[fx] == rank[fy] {
		rank[fx]++
	}
}
```

## 带权并查集
```go
package main

func demo(n int) {
    fa := make([]int, n)
    for i := range fa {
        fa[i] = i
    }
}

func find(fa []int, x int, w []int) int {
    if x == fa[x] {
        return x
    }
    f := fa[x]
    fa[x] = find(fa, fa[x], w)
    w[x] += w[f]
    return fa[x]
}

func merge(fa []int, x, y, v int, w []int) {
    fx, fy := find(fa, x, w), find(fa, y, w)
    if fx == fy {
        return
    }
    fa[fx] = fy
    w[fx] = -w[x] + v + w[y] // 这里可以画向量图来理解
}
```