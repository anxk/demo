# Redis

## 常见使用场景
1.	实现异步队列
一般使用list作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。缺点：在消费者下线的情况下，生产的消息可能会丢失，得使用专业的消息队列如rabbitmq等。能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
2.	分布式锁或悲观锁
先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的。
3.	实现附近的人功能
GEOADD key longitude latitude member [longitude latitude member ...]
将给定的位置对象（纬度、经度、名字）添加到指定的key。其中，key为集合名称，member为该经纬度所对应的对象。在实际运用中，当所需存储的对象数量过多时，可通过设置多key（如一个省一个key）的方式对对象集合变相做sharding（分表），避免单集合数量过多。成功插入后的返回值：(integer) N，其中N为成功插入的个数。
4.	实现乐观锁
使用事务中的watch来监控一个或多个key，当有key被修改，就自动取消整个事务，具体使用时需要重复这个过程直到没有碰撞为止。需要注意的是，当监视一个带过期时间的key时，即使key过期，事务仍然会执行。
5.	实现消息队列
比较简单的方式是使用list，消费者消费失败后，重新将value放回list；或者使用5.0版本后自带的stream。
6.	实现排名功能
使用有序集合实现，ZREVRANGEBYSCORE key max min [WITHSCORES]。
7.	实现高性能的tag系统
使用集合实现。
8.	确定热点数据集
例如：mysql 里有2000w数据，redis中只能存放20w数据，如何保证redis中的数据都是热点数据？redis内存上升到一定大小时会实施数据淘汰策略，可以使用lru淘汰算法来选出热点数据集。
9.	做触发器
使用发布订阅功能。
10.	做聊天系统
使用发布订阅功能。
11.	全页缓存（FPC）
12.	会话缓存（共享）（Session Cache）

## 运维
1.	redis自带了哪些工具？
redis-server，redis服务启动程序；
redis-cli，redis客户端，也可以使用telnet作为客户端；
redis-benchmark，性能测试工具，常用来测试指定配置下的qps；
redis-check-aof，aof日志检查和修复工具，例如：使用aof持久化方案时，如果最后追加的命令不完整，会导致redis启动失败，可以使用该工具来检查和去掉该段命令；
redis-check-dump，本地数据库检查工具；
2.	怎样测试redis连通性？
使用ping，如果收到pong说明服务端正常。
3.	推荐个第三方的redis管理工具？
Redis Desktop Manager。
4.	常用运维命令？
./redis-server ./redis.conf，启动服务端 
./redis-cli，启动客户端或者 ./redis-cli -h host -p port -a password 
config requirepass password，设置密码

1.	为什么需要持久化？
由于redis是一种内存型数据库，即服务器在运行时，系统为其分配了一部分内存存储数据，一旦服务器挂了，或者突然宕机了，那么数据库里面的数据将会丢失，为了使服务器即使突然关机也能保存数据，必须通过持久化的方式将数据从内存保存到磁盘中。
2.	redis持久化方案有哪些？
aof 和 rdb，默认是 rdb。rdb是通过保存redis在内存中的数据快照实现的，aof则是通过文件追加的方式将执行过的写命令依次保存实现的，另外aof方案还支持重写aof文件以防止文件过大。redis支持同时设置rdb和aof两种持久化方案，但是这样在重启时会首先使用aof方案重载数据，因为通常aof中保存的数据通常要更完整。
3.	rdb和aof各有什么优缺点？
rdb的优点是持久化文件小，恢复速度快，对性能影响小，缺点是不能实时持久化，并且不同版本需要满足特定格式，兼容性差； aof的优点是支持秒级持久化，兼容性好，缺点是持久化文件大、恢复速度慢、对性能影响大。
4.	如何选择持久化策略？
1. 如果redis中的数据完全丢失也没关系，例如被作为cache，那么无论单机还是主从架构，都可以不进行持久化； 
2. 在单机环境下，如果可以接受一定时间内数据的丢失则优先选rdb，这对性能有利，如果只能接受秒级的数据丢失，则应选择aof；
3. 在多数情况下，我们都会配置主从架构，slave的存在既可以实现数据热备，也可以进行读写分离分担负载，以及在master宕机后继续提供服务，这种情况一般在slave做aof持久化；
5.	redis持久化方案在备份和恢复时如何处理过期的键？
持久化时，rdb会检查被持久化的key是否过期，如果过期则直接忽略；aof在持久化时遇到过期的key时，会追加一条del命令；
恢复时rdb会检查key是否过期，过期则不加载；
6.	rdb持久化的触发条件有哪些？
手动触发和自动触发。
7.	如何开启aof持久化？
redis默认采用rdb持久化，要开启aof，需要在配置文件里配置：appendonly yes。
8.	如何恢复数据？
通过CONGIF GET DIR获取redis安装目录，然后将备份文件 (dump.rdb) 移动到这里并启动服务即可。

1.	redis部署方式有哪些？
单机模式、主从模式、哨兵模式、集群模式，参考https://www.cnblogs.com/L-Test/p/11626124.html
2.	redis主从模式解决了什么问题？
持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了就可能会导致数据丢失，通过redis的主从复制机制就可以避免这种单点故障。
3.	redis主从模式？
redis支持主从的模式。原则：master会将数据同步到slave，而slave不会将数据同步到master。slave启动时会连接master来同步数据。这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量。复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
4.	哨兵模式解决了什么问题？
在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。
5.	redis的分片或分区解决了什么问题？
使redis内存突破了单机限制。
6.	redis分区的缺点有哪些？
1. 涉及多个key的操作通常不会被支持，例如一般不能对两个set求交集；
2. 同时操作多个key，不能使用事务；
3. 备份比较复杂，需要不同的redis实例同时备份；
4. 动态扩容和缩容比较复杂，redis集群在运行时增删节点，可以做到最大程度的对用户透明的数据再平衡，但是一些客户端分区或者代理分区则不支持。
7.	redis分区方案有哪些？
1. 客户端分区，客户端分区就是在客户端确定数据会被存储到哪个redis节点或者从哪个redis节点获取数据，大多数客户端已经实现了客户端分区。
2. 代理分区，代理分区意味着客户端将请求发送给代理，由代理确定去哪个redis节点读取或者存储数据，代理根据给定的分区规则去请求对应的redis实例，然后将结果返回客户端。redis和memcached的一种代理是Twemproxy。
3. 查询路由，查询路由指的是，客户端随机请求任一个redis实例，然后该redis实例将请求转发给正确的redis节点。redis cluster实现了一种混合形式的查询路由，并不是将请求由一个redis节点转发到另一个redis节点，而是在客户端帮助下直接重定向到正确的节点。
8.	介绍一下redis哈希槽的概念？
redis集群没有使用一致性hash，而是引入了哈希槽的概念，redis有16384=128^2个哈希槽，每个key通过crc16校验后对16384取模来决定放在哪个槽内，集群每个节点负责一部分hash槽。
9.	redis读写分离模式？
通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。
10.	redis数据分片模型
为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。可以将每个节点看成都是独立的master，然后通过业务实现数据分片。结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。
11.	redis集群方案什么情况下会导致整个集群不可用？
假设有A/B/C三个节点组成集群，在没有复制模型的情况下，如果B挂了，那么集群会认为缺少对应的哈希槽，导致整个集群不可用。
12.	redis集群方案有哪些？
1. twemproxy，是一个代理，设置好被代理的redis后，将之前连接redis的地方改为连接代理，temproxy会以代理的身份接受请求并使用一致哈希算法，将请求转到具体的redis实例。优点是使用方便，对旧项目改造方便，缺点是redis节点数量改变后，数据无法自动迁移到新的节点。
2. codis，目前用的最多的方案，基本和twemproxy一致，但是支持在节点数量改变后，旧节点数据可以自动恢复到新hash节点。
3. redis cluster 3.0，使用的不是一致性哈希算法，而是哈希槽，支持节点设置从节点。
4. 在业务代码层实现，在代码层对key进行hash计算，然后找到对应的实例进行操作，对代码要求较高。

1.	redis的缓存淘汰策略？
1. noeviction：不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息，大多数写命令都会导致占用更多的内存（有极少数会例外）；
2. allkeys-lru：所有key通用，优先删除最近最少使用的key；
3. volatile-lru：只限于设置了expire的部分，优先删除最近最少使用的key；
4. allkeys-random：所有key通用，随机删除一部分key；
5. volatile-random：只限于设置了expire的部分，随机删除一部分 key；
6. volatile-ttl：只限于设置了expire的部分，优先删除剩余时间（time to live, TTL）短的key；
2.	redis的key删除策略？
1. 定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作；
2. 惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键；
3. 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定；
3.	redis三种key删除策略的优缺点？
定时删除优点：对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放所占用的内存；
定时删除缺点：对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除过期键上，将影响服务器的响应时间和吞吐量；
惰性删除优点：对cpu时间友好，在每次从键空间获取键时进行过期键检查并确定是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间；
惰性删除缺点：对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，这会可能导致它们会一直保存在内存中，造成内存泄露；
定期删除，由于定时删除会占用太多cpu时间，影响服务器的响应时间和吞吐量以及惰性删除浪费太多内存，有内存泄露的危险，所以出现一种整合和折中这两种策略的定期删除策略，定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，定时删除策略有效地减少了因为过期键带来的内存浪费；
4.	如何解决缓存和数据库数据的不一致性？
分布式环境下（单机就不用说了）非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，只能说，如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列。
5.	缓存击穿、缓存穿透和缓存雪崩的区别？
缓存穿透是指缓存和数据库中都没有对应的数据，例如：用户发起请求不存在数据的行为，这会导致数据库压力过大；缓存击穿是指缓存中没有数据但是数据库中存在相应数据，这时由于请求该数据的用户过多，导致数据库压力过大；缓存雪崩是指缓存中大量的数据在同一时间段内同时过期，同时查询量很大，导致数据库压力过大。
6.	如何解决缓存击穿？
使用mutex，简单来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去请求数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行请求数据库的操作并回设缓存；否则，就重试整个get缓存的方法。
7.	如何解决缓存雪崩？
1. 数据过期时间设置随机，让过期时间尽量均匀一些，防止同一时间段出现大量key同时过期的现象； 
2. 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有则读B，更新时同时更新A缓存和B缓存； 
3. 在缓存失效后，通过加锁或者队列的方式控制都数据库写缓存的线程数量，比如对某个key只允许一个线程去查询数据库和写缓存，其他线程等待，也可以做一个线程池；
8.	如何解决缓存穿透？
1. 对查询结果为空的情况也进行缓存，但是过期时间需要设置短一些或者该key对应数据插入后更新缓存；
2. 使用布隆过滤器，对一定不存在的key进行过滤，把所有可能存在的key放入一个大的bitmap中，查询时通过该bitmap进行过滤；

1.	redis介绍？
redis是一个基于内存的高性能键值数据库，基于C语言开发的,支持很多语言的客户端，redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。
2.	redis官方为什么不提供win版？有没有win 版？
因为linux用户量很大以及处理兼容性问题，官方只提供linux版的redis，但是社区有win版的redis（https://github.com/tporadowski/redis）。
3.	redis全称是什么？
remote dictionary server。
4.	redis常见数据类型有哪些？
string/hash/list/set/sorted set，redis的set 是通过哈希表实现的，所以添加/删除/查找的时间复杂度都是O(1)； 
除此之外还支持 bitmap（redis最大可设512M=2^32bit）,hyperloglog, geo 相关操作。 
redis没有空的list，当最后一个元素删除后，这个list也会被删除。 
redis存储数据是通过redisObject对象进行存储的。
5.	介绍一下redis的事务？
redis 事务以multi 开始以exec结束，可以保证事务中的命令连续执行，不被其他客户端的命令穿插，但需要注意的时事务中某条命令执行失败，不会影响其他命令的继续执行，另外redis的事务不支持回滚。对于命令的语法错误，在执行exec后会直接返回错误，对于运行错误（例如操作数据类型不匹配），则执行相应命令时会失败，但是事务内其他命令照常执行。
6.	介绍一下redis的管道功能？
在某些场景下我们在一次操作中可能需要执行多个命令，而如果我们只是一个命令挨一个命令去执行则会浪费很多网络时间，如果将命令一次性传输到 Redis中去再执行，则会减少很多时间开销,redis会缓存每条命令的执行结果，最后一起发送给客户端。但是需要注意的是 pipeline中的命令并不是原子性执行的，也就是说管道中的命令到达 Redis服务器的时候可能会被其他的命令穿插。
$(echo -en "PING\r\n SET runoobkey redis\r\nGET runoobkey\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n"; sleep 10) | nc localhost 6379
7.	redis和memcached相比的优势？
支持更为复杂的数据结构、支持数据持久化、支持主从模式备份、支持事务。
8.	noSQL是什么的简写？
Not Only SQL。
9.	redis数据库的选择？
单机模式下redis有16个数据库（可通过配置文件增加），编号0-15，在集群模式下不支持多数据库，默认0号数据库。
10.	redis集群最大节点数？
128^2 = 16384。
11.	redis是单线程的，如何提高多核机器的cpu使用率？
可以在同一个服务器部署多个redis实例，把他们当作单独的redis服务器使用；或者采用数据分片。
12.	redis内存使用完会怎样？
内存达到上限后，写命令会返回失败。解决办法，要么扩容内存，要么设置缓存淘汰机制。
13.	redis客户端和服务端使用什么协议通讯？
RESP。
14.	修改redis不重启可以吗？
有许多配置支持config set命令进行修改，而无需重启，从redis 2.2开始从aof切换到rdb也不需要重启。但是像升级redis或者设置某些config set 不支持的配置时仍然需要重启。
15.	redis 字符串类型的值最大存储多少内容？
512M。
16.	redis中海量数据的正确遍历姿势？
利用SCAN系列命令（SCAN、SSCAN、HSCAN、ZSCAN）完成数据迭代。
SCAN的参数没有key，因为其迭代对象是DB内数据；返回值都是数组，第一个值都是下一次迭代游标；时间复杂度：每次请求都是O(1)，完成所有迭代需要O(N)，N是元素数量；可用版本：version >= 2.8.0。
17.	redis除了做缓存外，还可以用来干什么？
分布式锁、消息发布订阅系统、基数统计、地理位置计算、队列（redis 5.0 新加的stream）。
18.	如何处理设置key时的并发问题？
这里的并发指的是多个redis的client同时set key引起的并发问题。比较有效的解决方案就是把redis的set操作放在队列中使其串行化，必须的一个一个执行，当然加锁也是可以的。
19.	redis 中如何判断 key 是否存在？
exists key key-name
20.	如何删除 redis 的key？
del key1 key2 ...
21.	使用redis-cli出现乱码怎么办？
redis-cli –raw
22.	redis还提供了哪些高级功能？
慢查询分析、性能测试、pipeline、事务、lua、bitmap、hyperloglog、pub/sub、geo、stream等。
23.	redis如何查看服务器的统计信息？
info [section]
24.	redis常见性能问题和解决方案？
1. master最好不要做任何持久化工作，如rdb内存快照和aof日志文件；
2. 如果数据比较重要，某个slave开启aof备份数据，策略为每秒同步一次；
3. 为了保证主从复制的速度和稳定性，master和slave最好在同一个局域网内；
4. 尽量避免在压力很大的主库上增加从库；
5. 主从复制不要用图状结构，用单向链表更为稳定，即：master <- slave1 <- slave2 <- ...；
25.	为什么redis采用单线程？
redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。
26.	redis慢查询日志?
redis客户端命令经过以下几个阶段，通过网络发送 -> 服务端排队 -> 执行命令 -> 通过网络返回结果，慢查询的时间不包括与客户端的通信、排队时间，而只是实际执行命令所需的时间（这是唯一在命令执行过程中线程被阻塞且不能同时处理其他请求的阶段）。
27.	redis中设置key过期的几种方式？
expire key seconds：设置 key 在 n 秒后过期；
pexpire key milliseconds：设置 key 在 n 毫秒后过期；
expireat key timestamp：设置 key 在某个时间戳（精确到秒）之后过期；
pexpireat key milliseconds-timestamp：设置 key 在某个时间戳（精确到毫秒）之后过期；
28.	redis是单线程的，但是为什么这么快？
1. 完全基于内存，绝大部分请求是纯粹的内存操作；
2. redis中的数据结构是专门进行设计的；
3. 采用单线程，避免了不必要的上下文切换和竞争条件带来的性能消耗；
4. 使用多路I/O复用模型，非阻塞IO，这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程；
5. 使用底层模型不同，它们（和memcached比）之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会比较浪费时间；
29.	redis集群会有写操作丢失吗？
redis并不能保证数据的强一致性，在特定条件下可能出现写操作丢失。
30.	布隆过滤器？
bloomfilter 就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回（用于解决缓存穿透）。布隆过滤器的关键就在于hash算法和容器大小。
31.	redis数据类型的内部存储结构？
redis没有直接使用C字符串（以\0结尾的字符数组），而是使用了SDS，在C字符串基础上增加了len和free字段：
struct sdshdr {
unsigned int len; // 字符串长度 
unsigned int free; // 空间长度 
char buf[]; //字符串 
}
字符串：数字是int，字符串不大于39字节使用embstr编码，超过时使用raw编码；list：链表；hash：哈希表； zset：跳表；
32.	redis集群节点之间是如何复制的？
异步复制。
33.	redis的module功能？
Redis module 是Redis 4.0 以后支持的新的特性，这里很多国外牛逼的大学和机构提供了很多牛逼的Module 只要编译引入到Redis 中就能轻松的实现我们某些需求的功能。在Redis 官方Module 中有一些我们常见的一些模块，我们在这里就做一个简单的使用。
neural-redis 主要是神经网络的机器学，集成到redis 可以做一些机器训练；
RedisSearch 主要支持一些富文本的的搜索；
RedisBloom 支持分布式环境下的Bloom 过滤器；
34.	介绍一下Twemproxy？
Twemproxy是Twitter维护的缓存代理系统，代理memcached的ASCII协议和Redis协议。它支持自动分区，当其代理的某个节点不可用时，会将其踢掉，这会改变原来的keys-instances的映射关系，所以应该在仅把redis作为缓存是使用该代理。另外，Twemproxy本身不存在单点故障，可以启动多个实例，然后由客户端连接任一实例。
35.	如何降低redis的内存使用？
一般来说，对于大的数据集，如果将每一个数据都进行键值对保存，会消耗较多的内存，因为redis键会存储类型信息、引用计数等信息，可以利用hash、list、set或sorted set等更紧促的方式来组织数据集。
36.	支持一致性哈希的redis客户端有哪些？
redis-rb、predis。
37.	redis内存模型？
used_memory：redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。
used_memory_rss：redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。
mem_fragmentation_ratio：内存碎片比率，该值是used_memory_rss / used_memory的比值。
mem_allocator**：redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。
38.	redis内存划分？
数据：作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中；
进程本身运行需要的内存：redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。
缓冲内存：缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。
内存碎片：内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。
39.	一个空的redis实例占多少内存？
一个空redis实例占用的内在只有1M左右。
40.	 Java的redis客户端有哪些？
redisson，Jedis，lettuce，官方推荐Redisson，Redisson和Jedis的区别是前者宗旨是促进使用者对redis的关注分离，后者提供了比较全面的redis命令支持。
41.	redis做持久化数据和做缓存时怎么扩容？
做缓存使用时，可以使用一致性哈希实现动态扩容缩容。做持久化存储使用时，必须使用固定的keys-to-nodes映射关系，节点数量一旦确定不能改变，否则（节点数量需要改变时），必须使用可以在运行时进行数据再平衡的一套系统，当前置邮redis自带的集群功能能做到。
42.	如何监听key过期等事件？
使用redis的keyspace notifications功能，Redis Keyspace Notifications – Redis。
43.	redis 分布式锁有什么缺陷？
redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。
