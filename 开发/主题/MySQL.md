# MySQL

## 常用命令

```shell script
# 启动和关闭 MySQL
systemctl start mysqld; systemctl stop mysqld
# 登录
mysql -h 127.0.0.1 -P 3306 -u username -p
# 列出所有数据库
show databases;
# 使用某个数据库
use dbname;
# 列出所有表
show tables;
# 查看表的字段描述
discribe table_name;
# 如何获取当前数据库版本
select version();
# 清空表中的所有内容，执行很快
truncate table table_name;
# 按行删除，而且可以通过 where 语句选择要删除的行
delete from table_name where xxx;
# 内连接、左连接、右连接内连接关键字 inner join，左连接 left join，右连接 right join，内连接是把匹配的关联数据显示出来，左连接是左边的表全部显示出来，右边的表显示出符合条件的数据，右连接正好相反
```

## 索引

### 五种索引

- 普通索引，最基本的索引，没有任何限制。
- 唯一索引，与普通索引类似，不同的是，索引列的值必须唯一，但允许有空值。
- 主键索引，它是一种特殊的唯一索引，不允许有空值，一张表只能有一个主键索引。
- 组合索引，就是将多个字段建到一个索引里，遵循“最左前缀”原则。
- 全文索引，主要应用于文本等字段。

### 覆盖索引

如果一个索引包含了查询语句中的字段，就叫做覆盖索引。

### 索引可以提高查询效率

由于索引的存储是有序的，查询效率为二分法查询效率  O(log N)。

## 事务

### 同时有多个事务在进行会发生什么

会发生三种情况，分别是脏读、不可重复读和幻读。

### 脏读、不可重复读和幻读分别是什么

**脏读：**A 事务读取 B 事务尚未提交的数据，此时如果 B 事务发生错误并执行回滚操作，那么 A 事务读取到的数据就是脏数据。

**不可重复读：**事务 A 在执行读取操作，由整个事务 A 比较大，前后需要经历很长的时间 。而在事务 A 第一次读取数据，比如此时读取了小明的年龄为 20 岁，事务 B 执行更改操作，将小明的年龄更改为 30 岁，此时事务 A 第二次读取到小明的年龄时，发现其年龄是 30 岁，和之前的数据不一样了，称为不可重复读。

**幻读：**事务 A 在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务 B 执行了新增数据的操作并提交后，这个时候事务 A 读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

### 不可重复读和幻读的区别以及解决办法

不可重复读是读取了其他事务更改的数据，**针对 update 操作**，解决：**使用行级锁**，锁定该行，事务 A 多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

幻读是读取了其他事务新增或删除的数据，**针对 insert 和 delete 操作**，解决：**使用表级锁**，锁定整张表，事务 A 多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

### InnoDB 四种事务隔离级别

- 读未提交，最低级别，任何情况都无法保证。
- 读已提交，可避免脏读的发生（Oracle 默认事务隔离级别）。
- 可重复读，可避免脏读、不可重复读的发生（MySQL InnoDB 默认事务隔离级别）。
- 串行化，可避免脏读、不可重复读、幻读的发生。

**注意：MySQL 不支持事务嵌套，MyISAM 引擎不支持事务。**

## 锁

### MyISAM 和 InnoDB 存储引擎使用的锁

MyISAM 采用表级锁，InnoDB支持行级锁和表级锁，默认为行级锁。表级锁和行级锁对比，表级锁是 MySQL 中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁，其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁；行级锁是 MySQL 中锁定粒度最小的一种锁，只针对当前操作的行进行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

### 排他锁

#### 记录锁（行锁）

```sql
# 它会在 id=1 的记录上加上记录锁，以阻止其他事务插入、更新、删除这一行
select * from goods where `id`=1 for update;
```

#### 间隙锁

```sql
# 双开区间，不包含 id=1 和 id=10 这两条记录
select * from goods where id between 1 and 10 for update;
```

### 乐观锁

数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。

### 悲观锁

悲观锁的实现通常使用 InnoDB 自带的锁实现。

## 运维

### MySQL 如何实施读写分离
采用主从复制架构，根据读写比例合理的设置从节点数量。

### MySQL 的 SQL 语句如何优化
- 在表中建立索引，优先考虑 where、group by 使用到的字段
- 尽量避免使用 select *，返回无用的字段会降低查询效率
- 尽量避免使用 in 和 not in，会导致数据库引擎放弃索引进行全表扫描
- 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描
- 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描

### 如何在线正确清理 binlog
```shell script
# 自动清除, 设置 binlog 过期时间为 30 天
mysql> set global expire_logs_days=30;
# 手动清除, 删除 mysql-bin.000007 之前的所有 binlog 日志
mysql> purge binary logs to "mysql-bin.000007";
```

### sleep 线程过多如何解决
```shell script
# mysqladmin -uroot -p123456 processlist
mysql> show processlist\G
# 可以酌情去 kill
```
修改 my.cnf 文件里的 wait_timeout 的值，让其更小一些，默认 wait_timeout = 28800，这里改为 100
```shell
mysql> set global wait_timeout = 100;
mysql> show global variables like "wait_timeout";
```

### sort_buffer_size 参数作用
MySQL 执行排序使用的缓冲大小，如果想要增加 order by 的速度，首先看是否可以让 MySQL 使用索引而不是额外的排序阶段，如果不能，可以尝试增加 sort_buffer_size 变量的大小。
```shell
mysql> set global sort_buffer_size = 131072; # 单位为 B，即 128KB，默认 64K
```

### MySQL 问题排查都有哪些手段
- 使用 show processlist 命令查看当前所有连接信息。
- 使用 explain 命令查询 SQL 语句执行计划。
- 开启慢查询日志，查看慢查询的 SQL。

### 主从复制原理
主：binlog 线程，记录所有改变了数据库数据的语句，放进 master 上的 binlog 中。

从：IO 线程，在使用 start slave 之后，负责从 master 上拉取 binlog 内容，放进自己的 relay log 中。

从：SQL 执行线程，执行 relay log 中的语句。

### 主从同步的异步模式和半同步模式
异步模式：主库更新完，从库拉取 binlog，然后执行对应语句；半同步模式：主库先将 binlog 发送从库，如果收到确认消息，再提交事务，该方式不是 MySQL 内置，需要安装插件。

### 如何做主从数据一致性校验

主从一致性校验有多种工具 例如 checksum、mysqldiff、pt-table-checksum 等。

### 如何加强 MySQL 安全
- 避免直接从互联网访问 MySQL 数据库，确保特定主机才拥有访问权限
- 定期备份数据库
- 禁用或限制远程访问，在 my.cnf 文件里设置 bind-address 指定 IP
- 移除 test 数据库（默认匿名用户可以访问 test 数据库）
- 禁用 local infile，在 my.cnf 里 [mysqld] 下添加 set-variable=local-infile=0
- 移除匿名账户和废弃的账户
- 限制 MySQL 数据库用户的权限
- 移除和禁用 .mysql_history 文件
```shell script
cat ~/.mysql_history
export MYSQL_HISTFILE=/dev/null
```

## 数据类型

### float 和 double
float 最多可以存储 **8 位**的**十进制数**，并在内存中占 **4 字节**，double 最多可以存储 **16 位**的**十进制数**，并在内存中占 **8 字节**。

### int(1) 和 int(10)
int(1) 和 int(10) 所能存储的数字大小以及占用的空间都是相同的，只是在展示时按照不同长度展示。

### char 和 varchar
char 是一个定长字段，假如申请了 char(10) 的空间，那么无论实际存储多少内容，该字段都占用 10 个字符，而 varchar 是变长的，也就是说申请的只是最大长度，占用的空间为实际字符长度 +1。在检索效率上来讲，char > varchar，因此在使用中，如果确定某个字段的值的长度，可以使用 char，否则应该尽量使用 varchar。例如存储用户 MD5 加密后的密码，则应该使用 char。

### 存储密码、散列，应该使用什么类型

对于密码、散列、盐、用户身份证号等固定长度的字符串应该使用 char 而不是 varchar 来存储，这样可以节省空间且提高检索效率。

### 字段值为什么建议定义为 NOT NULL
NULL 值会占用更多的字节，且会在程序中造成很多与预期不符的情况。

## 底层实现

### B 树和 B+ 树
B 树，节点既存储关键字也存储数据（记录）；B+ 树，非叶子结点只存储关键字（子树中最大、最小关键字），叶子结点本身依关键字的大小自小而大的顺序链接，且每个叶子结点包含指向对应数据（记录）的指针。对于 B+ 树而言，一次性读入内存中的需要查找的关键字更多，相对来说 IO 读写次数也就更低，另外查找必须走一条从根结点到叶子结点的路，不会像 B 树一样提前终止遍历，所以查询时间更稳定。

## 设计和管理

### 横表和竖表

横表指的是将属性作为列，也是平时大部分时候的用法；竖表指的是将属性作为“属性名”列的值的这种组织方式。竖表可以灵活、动态的加新属性，如果每种属性的记录数量不一样，用竖表会更节省空间。

### SQL 版本管理用什么工具

SQL 版本管理一般使用 flyway。

## 杂七杂八

### 存储过程

存储过程是一些预编译的 SQL 语句，平时使用比较少。

### InnoDB 引擎表的自增主键最大 id 是记录在内存中

一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？引擎类型如果是 MyISAM，那 id 就是 8，如果是 InnoDB，那 id 就是6，InnoDB 表会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。
