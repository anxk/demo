# MySQL

## delete 和 truncate 删除数据的区别
- truncate table test 执行更快，清空物理文件，清空表中的所有内容
- delete from test 是逻辑删除，按行删除，而且可以通过 where 语句选择要删除的行

# MyISAM 和 InnoDB 存储引擎使用的锁
MyISAM 采用表级锁(table-level locking)，InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁。
表级锁和行级锁对比，表级锁是 MySQL 中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁，
其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁；
行级锁是 MySQL 中锁定粒度最小的一种锁，只针对当前操作的行进行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，
但加锁的开销也最大，加锁慢，会出现死锁。

## InnoDB存储引擎的行级锁的算法有三种
- Record lock：单个行记录上的锁；
- Gap lock：间隙锁，锁定一个范围，不包括记录本身；
- Next-key lock：record+gap锁定一个范围，包含记录本身；

## 四种隔离级别
Serializable (串行化)：可避免脏读、不可重复读、幻读的发生；
Repeatable read (可重复读)：可避免脏读、不可重复读的发生；（MySQL InnoDB默认事务隔离级别，Oracle默认采用的读已提交）
Read committed (读已提交)：可避免脏读的发生；
Read uncommitted (读未提交)：最低级别，任何情况都无法保证；

## 同时有多个事务在进行会发生什么
脏读、不可重复读和幻读

## MySQL如何实施读写分离
采用主从复制，根据读写比例合理的设置从节点数量

## 实现乐观锁
数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，
自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁

## MySQL 的内连接、左连接、右连接有什么区别
内连接关键字：inner join；左连接：left join；右连接：right join。
内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。

## 一张自增表里面总共有7条数据，删除了最后2条数据，重启MySQL数据库，又插入了一条数据，此时id是几
表类型如果是 MyISAM，那 id 就是8，表类型如果是 InnoDB，那 id 就是6，InnoDB 表只会把自增主键的最大 id 记录在内存中，
所以重启之后会导致最大id丢失。

## MySQL 索引的种类
- 普通索引：最基本的索引，没有任何限制
- 唯一索引：与普通索引类似，不同的是，索引列的值必须唯一，但允许有空值
- 主键索引：它是一种特殊的唯一索引，不允许有空值，一张表只能有一个主键
- 组合索引：就是将多个字段建到一个索引里

## MySQL 的 SQL 语句如何优化
- 在表中建立索引，优先考虑where、group by使用到的字段
- 尽量避免使用select *，返回无用的字段会降低查询效率
- 尽量避免使用in和not in，会导致数据库引擎放弃索引进行全表扫描
- 尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描
- 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描

## 如何在线正确清理 MySQL binlog
```shell script
# 自动清除, 设置binlog过期时间为30天
mysql> set global expire_logs_days=30;   #
# 手动清除, 删除mysql-bin.000007之前的所有binlog日志
mysql> purge binary logs to "mysql-bin.000007";
```

## MySQL Sleep 线程过多如何解决
```shell script
# mysqladmin -uroot -p123456 processlist
mysql> show processlist\G
```
修改 my.cnf 文件里的 wait_timeout 的值，让其更小一些，默认 wait_timeout = 28800，这里改为 100
mysql> set global wait_timeout = 100;
mysql> show global variables like "wait_timeout";

## sort_buffer_size参数作用？如何在线修改生效
mysql执行排序使用的缓冲大小。如果想要增加order by的速度，首先看是否可以让mysql使用索引而不是额外的排序阶段，如果不能，
可以尝试增加sort_buffer_size变量的大小。
mysql> set global sort_buffer_size =131072; #单位为B，即128KB，默认64K

## MySQL问题排查都有哪些手段
- 使用show processlist命令查看当前所有连接信息
- 使用explain命令查询SQL语句执行计划
- 开启慢查询日志，查看慢查询的SQL

## 主从复制原理
主：binlog线程，记录所有改变了数据库数据的语句，放进master上的binlog中；从：IO线程，在使用start slave之后，
负责从master上拉取binlog内容，放进自己的relay log中；从：SQL执行线程，执行relay log中的语句

## 常用命令
```shell script
# 启动和关闭MySQL
systemctl start mysqld, systemctl stop mysqld
# 登录
mysql -u username -p
# 列出所有数据库
show databases
# 使用某个数据库
use dbname
# 列出所有表
show tables
# 查看表的字段描述
discribe table_name
# 如何获取当前数据库版本
select version()
```

## 主从同步的异步同步模式和半同步模式
异步模式主库更新完，从库拉取binlog，然后执行对应语句；半同步是主库先将binlog发送从库，如果收到确认消息，再提交事务，
该方式不是mysql内置，需要安装插件。

## 如何加强 MySQL 安全，请给出可行的具体措施
- 避免直接从互联网访问mysql数据库，确保特定主机才拥有访问权限
- 定期备份数据库
- 禁用或限制远程访问，在my.cnf文件里设置bind-address指定ip
- 移除test数据库（默认匿名用户可以访问test数据库）
- 禁用local infile
```shell script
mysql> select load_file("/etc/passwd"); # 或在my.cnf里[mysqld]下添加set-variable=local-infile=0
```
- 移除匿名账户和废弃的账户；
- 限制mysql数据库用户的权限；
- 移除和禁用.mysql_history文件
```shell script
cat ~/.mysql_history
export MYSQL_HISTFILE=/dev/null
```

## 请详细描述char(4)和varchar(4)的差别
char(4)定义的是固定长度4，存储时，如果字符数不够4位，会在后面用空格补全存入数据库。varchar(4)定义的是变长长度，存储时，
如果字符没有达到定义的位数4时，也不会在后面补空格

## float 和 double 的区别是什么
float 最多可以存储 8 位的十进制数，并在内存中占 4 字节
double 最可可以存储 16 位的十进制数，并在内存中占 8 字节

## 请详细描述SQL语句分类及对应代表性关键字？
- DDL(Data Definition Language)，数据库定义语言（create、alter、drop)，管理基础数据库，例如：库，表
- DCL(Data Control Language)，数据控制语言（grant、revoke、commit、rollback），用户授权，权限回收，数据提交回滚等
- DML（Data Manipulation Language)，数据操作语言（select、insert、delete、update），针对数据库里的表，记录

## 如何做主从数据一致性校验
主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等

## mysql不支持事务嵌套

## varchar(10)和int(10)代表什么含义
varchar的10代表了申请的空间长度，也是可以存储的数据的最大长度，而int的10只是代表了展示的长度，不足10位以0填充。
也就是说，int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的，只是在展示时按照长度展示

## MySQL中的varchar和char有什么区别
char是一个定长字段，假如申请了char(10)的空间，那么无论实际存储多少内容。该字段都占用10个字符，而varchar是变长的，
也就是说申请的只是最大长度，占用的空间为实际字符长度+1，最后一个字符存储使用了多长的空间。在检索效率上来讲，char > varchar，
因此在使用中，如果确定某个字段的值的长度，可以使用char，否则应该尽量使用varchar。例如存储用户MD5加密后的密码，则应该使用char

## MySQL版本管理用什么工具
flyway

## 如果要存储用户的密码散列，应该使用什么字段进行存储
密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率

## 字段为什么要求定义为not null
null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。

## ACID原则
关系性数据库需要遵循ACID规则，具体内容如下： 
原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性：执行事务前后，数据保持一致；
隔离性：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；
持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

## 什么是关系型数据库
关系型数据库是支持采用了关系模型的数据库，简单来说，关系模型就是指二维表模型，而一个关系数据库就是由二维表及其之间的联系所组成的一个数据组织。

## MySQL的binlog有有几种录入格式？分别有什么区别？
有三种格式，statement，row和mixed。
statement模式下，记录单元为语句。即每一个sql造成的影响会记录。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
row级别下，记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
mixed， 一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。

## MySQL优化
- 开启查询缓存，优化查询；
- explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你，你的索引主键被如何利用的，你的数据表是如何被搜索和排序的；
- 当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据；
为搜索字段建索引；
- 使用ENUM而不是VARCHAR，如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM而不是VARCHAR；
- Prepared Statements，Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题，Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击；
- 垂直分表；
- 选择正确的存储引擎；

## MySQL 中 MyISAM 和 InnoDB 的区别有哪些
### 区别
- InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
- InnoDB支持外键，而MyISAM不支持，对一个包含外键的InnoDB表转为MYISAM会失败；
- InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高，但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据，因此主键不应该过大，因为主键太大，其他索引也都会很大，而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的；
- InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描，而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
- InnoDB不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；
### 如何选择
- 是否要支持事务，如果要请选择InnoDB，如果不需要可以考虑MyISAM；
- 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB；
- 系统奔溃后，MyISAM恢复起来更困难，能否接受；
- MySQL 5.5版本开始InnoDB已经成为MySQL的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差；

## 什么是覆盖索引
如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引

# 大表优化
当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下

### 限定数据的范围
务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内

### 读写分离
经典的数据库拆分方案，主库负责写，从库负责读

### 缓存
使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存

### 垂直分区
根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，
甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。（垂直拆分的优点是可以使得行数据变小，
在查询时减少读取的Block数，减少I/O次数，此外，垂直分区可以简化表的结构，易于维护；缺点是主键会出现冗余，需要管理冗余列，
并会引起join操作，可以通过在应用层进行join来解决,此外，垂直分区会让事务变得更加复杂；）

### 水平分区
保持数据表结构不变，通过某种策略存储数据分片，这样每一片数据分散到不同的表或者库中，达到了分布式的目的，
水平拆分可以支撑非常大的数据量。水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。
举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。
水品拆分可以支持非常大的数据量。需要注意的一点是，分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，
其实对于提升MySQL 并发能力没有什么意义，所以 水品拆分最好分库。水平拆分能够 支持非常大的数据量存储，应用端改造也少，
但分片事务难以解决 ，跨界点join 性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐尽量不要对数据进行分片，因为拆分会带来逻辑、
部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，
这样可以减少一次和中间件的网络I/O。

### 下面补充一下数据库分片的两种常见方案
客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现，当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。
中间件代理：在应用和数据中间加了一个代理层，分片逻辑统一维护在中间件服务中，我们现在谈的 Mycat、360的Atlas、网易的DDB等等都是这种架构的实现。

## 在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢
- 使用不等于查询
- 列参与了数学运算或者函数
- 在字符串like时左边是通配符，类似于'%aaa'
- 当mysql分析全表扫描比使用索引快的时候不使用索引
- 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引

## 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？
MySQL提供了explain命令来查看语句的执行计划，MySQL在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，
也就是执行计划，其中包含了许多信息。 可以通过其中和索引有关的信息来分析是否命中了索引，例如possilbe_key，key,key_len等字段，
分别说明了此语句可能会使用的索引，实际使用的索引以及使用的索引长度。

## 在建立索引的时候，都有哪些需要考虑的因素呢？
建立索引的时候一般要考虑到字段的使用频率，经常作为条件进行查询的字段比较适合。如果需要建立联合索引的话，还需要考虑联合索引中的顺序。
此外也要考虑其他方面，比如防止过多的所有对表造成太大的压力。这些都和实际的表结构以及查询方式有关。

## 联合索引是什么?为什么需要注意联合索引中的顺序？
MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，
否则无法命中索引。具体原因为：MySQL使用索引时需要索引有序，假设现在建立了"name,age,school"的联合索引，那么索引的排序为：
先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。当进行查询时，此时索引仅仅按照name严格有序，
因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。
因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

## 联合索引？
- 联合索引是两个或更多个列上的索引，对于联合索引，MySQL从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a, b, c)，可以支持a、a, b、a,b,c这3种组合进行查找，但不支持b, c进行查找，当最左侧字段是常量引用时，索引就十分有效。
- 利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。

## 什么情况下可以不建或者少建索引？
- 表记录太少；
- 经常插入、删除、修改的表；
- 数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度；
- 经常和主字段一块查询但主字段索引值比较多的表字段；

## 行级锁定的优点？
- 当在许多线程中访问不同的行时只存在少量锁定冲突；
- 回滚时只有少量的更改；
- 可以长时间锁定单一的行；

## 行级锁定的缺点？
- 比页级或表级锁定占用更多的内存；
- 当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁；
- 如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多；
- 用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定；

## 什么是表分区？
表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。

## 表分区与分表的区别？
分表指的是通过一定规则，将一张表分解成多张不同的表，比如将用户订单记录根据时间成多个表。分表与分区的区别在于分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。

## 表分区有什么好处？
- 存储更多数据，分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备，和单个磁盘或者文件系统相比，可以存储更多数据；
- 优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率，涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果；
- 分区表更容易维护，例如：想批量删除大量数据可以清除整个分区；
- 避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3文件系统的inode锁竞争等；

## 分区表的限制因素？
- 一个表最多只能有1024个分区；
- MySQL 5.1中，分区表达式必须是整数，或者返回整数的表达式，在MySQL 5.5中提供了非整数表达式分区的支持；
如果分区字段中有主键或者唯一索引的列，那么有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，3、要么包含全部主键和索引列；
- 分区表中无法使用外键约束；
- MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区；

## 如何判断当前MySQL是否支持分区？
命令：show variables like '%partition%' 运行结果，have_partintioning的值为YES，表示支持分区。

## MySQL支持的分区类型有哪些？
RANGE分区：这种模式允许将数据划分不同范围，例如可以将一个表通过年份划分成若干个分区；
LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照list中的值分区，与RANGE的区别是，range分区的区间范围值是连续的；
HASH分区：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表；
KEY分区：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的；

## 说一说三个范式
第一范式：每个列都不可以再拆分。第二范式：非主键列完全依赖于主键，而不能是依赖于主键的一部分。第三范式：非主键列只依赖于主键，不依赖于其他非主键。在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。 事实上我们经常会为了性能而妥协数据库的设计。
第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。
第三范式：任何非主属性不依赖于其它非主属性。

## 字符集及校对规则
字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。Mysql中每一种字符集都会对应一系列的校对规则。
Mysql采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。
比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集）。

## 什么是存储过程？有哪些优缺点
存储过程是一些预编译的SQL语句，1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个
方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了；2、存储过程是一个预编译
的代码块，执行效率比较高，一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全；
但是，在互联网项目中，其实是不太推荐存储过程的，比较出名的就是阿里的《Java开发手册》中禁止使用存储过程，我个人的理解是，在互联网项目中，
迭代太快，项目的生命周期也比较短，人员流动相比于传统的项目也更加频繁，在这样的情况下，存储过程的管理确实是没有那么方便，同时，
复用性也没有写在服务层那么好。

## 数据库表创建注意事项？
### 字段名及字段配制合理性：
剔除关系不密切的字段；
字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；
字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；
字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；
字段名不要使用保留字或者关键字；
保持字段名和类型的一致性；
慎重选择数字类型；
给文本字段留足余量；
### 系统特殊字段处理及建成后建议：
添加删除标记（例如操作人、删除时间）；
建立版本机制；
### 表结构合理性配置：
多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；
多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！
### 其它建议：
对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；
使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；
给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；
避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；
建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；

## 关于MVCC？
MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) ，与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control。MVCC最大的好处：读不加锁，读写不冲突，在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。

## 在MVCC并发控制中，读操作可以分成两类？
快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁也不加，所以不会阻塞其他事务的写）；
当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录；

## key和index的区别？
key是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的），包括primary key, unique key, foreign key等；
index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（MySQL中的InnoDB表空间）以一个类似目录的结构存储，索引要分类的话，分为前缀索引、全文本索引等；

## 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，什么是聚簇索引?
在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

## 非聚簇索引一定会回表查询吗?
不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。

## 为什么用自增列作为主键？
1、如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)；
2、数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）；
3、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页；
4、如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面；

## 为什么使用数据索引能提高效率？
数据索引的存储是有序的，在有序的情况下，通过索引查询一个数据是无需遍历索引记录的，极端情况下，数据索引的查询效率为二分法查询效率，趋近于O(logN)

## 哈希索引的优势？
等值查询，哈希索引具有绝对优势（前提是：没有大量重复键值，如果有大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题）。

## 哈希索引不适用的场景？
不支持范围查询、不支持索引完成排序、不支持联合索引的最左前缀匹配规则。通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：
select id, name from table where name='李明'; # 仅等值查询
而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。
注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。

## 为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？
1、B+树的磁盘读写代价更低：B+树的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低；
2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## B+树索引和哈希索引的区别？
B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的
哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可，是无序的

## B树和B+树的区别？
B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null，叶子结点不包含任何关键字信息
B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，
所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B树的非终节点也包含需要查找的有效信息)
